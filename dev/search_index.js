var documenterSearchIndex = {"docs":
[{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"EditURL = \"example_three_users_atleasttwo.jl\"","category":"page"},{"location":"examples/example_three_users_atleasttwo/#Example-1:-Key-player-but-not-alone","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"","category":"section"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"This example aims to describe the simple use of the package for a 3-user case. The major reward allocation techniques supported by the package are considered, using the enumerative technique.","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"The sample game considered in this example has the following characteristics:","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"there are 3 players: 1, 2 and 3\neach user can join or not the coalition\nthe utility value is:\nalways 0 if player 1 does not join the coalition\n+1 if player 1 joins the coalition but it is not alone","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"In the following, the game is constructed.","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"First, the packages are imported","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"using TheoryOfGames\nusing JuMP, Ipopt","category":"page"},{"location":"examples/example_three_users_atleasttwo/#Initialization-of-the-game","page":"Example 1: Key player but not alone","title":"Initialization of the game","text":"","category":"section"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Define the set of the users that can join or not the coalition","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"player_set = [1, 2, 3]","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Define the utility function that is a function that:","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"takes as input an iterable that represents a coalition\nit returns a value in agreement to what discussed above and here summarized:\nit returns +1 if player 1 joins the coalition but it is not alone (1 in x)  length(x)\nit returns 0 if player 1 does not join the coalition (otherwise) `else condition","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"utility = x->((1 in x) && (length(x) > 1)) ? 1.0 : 0.0","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Show the value of utility for the coalition where only user 1 joins","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"utility([1])","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Show the value if also user 2 joins","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"utility([1, 2])","category":"page"},{"location":"examples/example_three_users_atleasttwo/#Calculation-of-selected-reward-allocation-functions","page":"Example 1: Key player but not alone","title":"Calculation of selected reward allocation functions","text":"","category":"section"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Define the Enumerative object","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"enum_obj = EnumMode(player_set, utility)","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Calculate shapley value","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"shapley_value(enum_obj)","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Define the optimizer needed for nucleolus and var least core techniques. We use the default Ipopt and disable the output for simplicity (print_level=0).","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"OPTIMIZER = optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0)","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Calculate nucleolus","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"nucleolus(enum_obj, OPTIMIZER)","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"Calculate var least core","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"var_least_core(enum_obj, OPTIMIZER)","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"info: Info\nView this file on Github.","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"","category":"page"},{"location":"examples/example_three_users_atleasttwo/","page":"Example 1: Key player but not alone","title":"Example 1: Key player but not alone","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API reference/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"API reference/","page":"API reference","title":"API reference","text":"Modules = [TheoryOfGames]\nOrder   = [:function, :type]","category":"page"},{"location":"API reference/#FileIO.load-Tuple{AbstractString, AbstractCalcMode}","page":"API reference","title":"FileIO.load","text":"load(output_file::AbstractString)\n\nFunction to load the results and the model to the hard drive\n\n\n\n\n\n","category":"method"},{"location":"API reference/#FileIO.save-Tuple{AbstractString, AbstractCalcMode}","page":"API reference","title":"FileIO.save","text":"save(output_file::AbstractString, game_mode<:AbstractCalcMode)\n\nFunction to save the Mode element of TheoryOfGames.jl\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames._create_history_row-NTuple{8, Any}","page":"API reference","title":"TheoryOfGames._create_history_row","text":"Auxiliary function to create history rows for iterative solving methods\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.compute_relative_tol","page":"API reference","title":"TheoryOfGames.compute_relative_tol","text":"Auxiliary function to compute the relative tolerance between two quantities x and y\n\n\n\n\n\n","category":"function"},{"location":"API reference/#TheoryOfGames.empty_set-Tuple{Any}","page":"API reference","title":"TheoryOfGames.empty_set","text":"Return the empty set of the coalition\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.in_core-Tuple{EnumMode, Any}","page":"API reference","title":"TheoryOfGames.in_core","text":"in_core(mode, optimizer; verbose, raw_outputs)\n\nFunction to calculte a stable profit distribution that belongs to the core for profit distribution for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nincoredist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.in_core-Tuple{IterMode, Any}","page":"API reference","title":"TheoryOfGames.in_core","text":"in_core(mode, optimizer; verbose, ...)\n\nFunction to calculte a stable profit distribution that belongs to the core for profit distribution for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : IterMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nincoredist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.least_core-Tuple{EnumMode, Any}","page":"API reference","title":"TheoryOfGames.least_core","text":"least_core(mode, utilities, optimizer; verbose, raw_outputs)\n\nFunction to calculte the least core profit distribution for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique playerset : Vector     Vector of the players of the coalition optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status rawoutputs : Bool (optional, default false)     When true, it returns all raw outputs\n\nOutputs\n\nleastcore_dist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.least_core-Tuple{IterMode, Any}","page":"API reference","title":"TheoryOfGames.least_core","text":"leastcore(mode, playerset, utilities, optimizer; verbose)\n\nFunction to calculte the least core profit distribution for a game described by the utility function and the grand coalition of player_set. This function implements an iterative approach by using a column generating approach to iteratively add constraints to the master problem. To do so, the callback function stored in the mode category is exploited\n\nInputs\n\nmode : IterMode     Calculation mode that contains the reference to the callback function     that given a profit distribution scheme, returns a tuple of     the set of the coalition with the worst profit and its total benefit to be shared     callbackworstcoalition accepts one argument (current profit sharing) optimizer : Any     Optimizer function for the JuMP model used for computation purposes starttime : (optional, default nothing)     Specify the initial time of the method; if nothing the value is initialized by time() rtol : Number (optional, default 1e-2)     Relative tolerance of the convergence process atol : Number (optional, default 1e-2)     Absolute tolerance of the convergence process lowerbound : Number (optional, default nothing)     Lower bound of the variables of the problem (benefit distribution and margin of the worst coalition) upperbound : Number (optional, default nothing)     Upper bound of the variables of the problem (benefit distribution and margin of the worst coalition)     When nothing, the value is automatically set to the benefit of the grand coalition verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status rawoutputs : Bool (optional, default false)     When true, it returns all raw outputs usestartvalue : Bool (optional, default false)     When true, in the iterative process the previous iteration value is used as initialization     for the followin iteration maxiter : Bool (optional, default 100)     Maximum number of iterations of the process preloadcoalitions : Vector (optional, default empty)     List of coalitions whose benefit shall be automatically     included before the iterative procedure starts bestobjectivestopoption : String (optional, default nothing)     Name of the option to stop the lower problem as it reaches a preset value.     When this option is nothing, this feature is not used.     When this option is non-nothing, in every iteration, a minimum convergence criterion is added     so to stop the lower problem as soon as a minimum fesible objective function is reached.     This minimum objective value is obtained with respect to the solution of the master problem     multiplied by the factor \"bestobjectivestoptolerance\"     If gurobi is used, this option is BestObjStop bestobjectivestoptolerance : Number (optional, default 0.05)     Tolerance used in the \"bestobjectivestopoption\" approach lowerrelaxationstopoption : String (optional, default nothing)     Name of the option used to setup the stop criterion of the optimization as soon as     the lowest bound reaches the tolerance specified by tolerancelowerrelaxationstop option tolerancelowerrelaxationstop : double (optional, default 0.0)     When lowerrelaxationstopoption is enabled, this option specifies the tolerance used     to stop the loop\n\nOutputs\n\nprofitdistribution     Benefit distribution by player minsurplus     Benefit of the coalition with the minimum surplus history\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.nucleolus-Tuple{EnumMode, Any}","page":"API reference","title":"TheoryOfGames.nucleolus","text":"nucleolus(mode, utilities; verbose, tol, raw_outputs)\n\nFunction to calculte the nucleolus profit distribution for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status tol (optional, default 1e-5)     Accepted tolerance for identifying the active constraints in the optimization     procedure raw_outputs : Bool (optional, default false)     When true, it returns all raw outputs\n\nOutputs\n\nnucleolus_dist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.number_coalitions-Tuple{Any}","page":"API reference","title":"TheoryOfGames.number_coalitions","text":"Get the total number of coalitions\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.ref_in_core-Tuple{EnumMode, Any, Any}","page":"API reference","title":"TheoryOfGames.ref_in_core","text":"ref_in_core(mode, ref_dist, optimizer; verbose)\n\nFunction to calculte a stable profit distribution that belongs to the core and minimizes the variance of the profit allocation among the players with respect to a pre-defined reward distribution function for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique ref_dist : AbstrctDict     Reference distribution by player optimizer : Any     Optimizer function for the JuMP model used for computation purposes norm : Any     Normalization denominator for every player     Default value nothing, hence for every player the Normalization     factor is 1.0 verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nspecificrefincoredist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.ref_in_core-Tuple{IterMode, Any, Any}","page":"API reference","title":"TheoryOfGames.ref_in_core","text":"ref_in_core(mode, ref_dist, optimizer; verbose)\n\nFunction to calculte a stable profit distribution that belongs to the core and minimizes the variance of the profit allocation among the players with respect to a pre-defined reward distribution function for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : IterMode     Calculation mode: enumerative technique refdist : AbstrctDict     Reference distribution by player optimizer : Any     Optimizer function for the JuMP model used for computation purposes norm : Any     Normalization denominator for every player     Default value nothing, hence for every player the Normalization     factor is 1.0 numericalmultiplier : Float (default 1e-3)     Multiplier to adjust numerical issues verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nspecificrefincoredist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.ref_least_core-Tuple{EnumMode, Any, Any}","page":"API reference","title":"TheoryOfGames.ref_least_core","text":"ref_least_core(mode, ref_dist, optimizer; norm, verbose)\n\nFunction to calculte a stable profit distribution that belongs to the least core and minimizes the variance of the profit allocation among the players with respect to a pre-defined reward distribution function for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : AbstractCalcMode     Calculation mode: enumerative technique ref_dist : AbstrctDict     Reference distribution by player optimizer : Any     Optimizer function for the JuMP model used for computation purposes norm (optional, default nothing)     Normalization denominator for every player     Default value nothing, hence for every player the Normalization     factor is 1.0 verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nspecificleastcore_dist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.ref_least_core-Tuple{IterMode, Any, Any}","page":"API reference","title":"TheoryOfGames.ref_least_core","text":"ref_least_core(mode, ref_dist, optimizer; norm, verbose)\n\nFunction to calculte a stable profit distribution that belongs to the least core and minimizes the variance of the profit allocation among the players with respect to a pre-defined reward distribution function for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : AbstractCalcMode     Calculation mode: enumerative technique ref_dist : AbstrctDict     Reference distribution by player optimizer : Any     Optimizer function for the JuMP model used for computation purposes norm (optional, default nothing)     Normalization denominator for every player     Default value nothing, hence for every player the Normalization     factor is 1.0 verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nspecificleastcore_dist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.shapley_value-Tuple{EnumMode}","page":"API reference","title":"TheoryOfGames.shapley_value","text":"shapley_value(mode; verbose)\n\nFunction to calculte the shapley value for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nshapley_value : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.specific_in_core-Tuple{EnumMode, Function, Any}","page":"API reference","title":"TheoryOfGames.specific_in_core","text":"specific_in_core(mode, dist_objective, optimizer; verbose, raw_outputs)\n\nFunction to calculte a stable profit distribution that belongs to the core and maximizes a specific distribution objective specified by distobjective for a game described by the utility function and the grand coalition of playerset.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique distobjective : Function     Function to build the objective function of the profit distribution     It shall a function with two arguments, which are the JuMP model and the player set,     and it shall build the objective functions using the JuMP @NLobjective or @objective     commands optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status rawoutputs : Bool (optional, default false)     When true, it returns all raw outputs\n\nOutputs\n\nspecificincore_dist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.specific_in_core-Tuple{IterMode, Function, Any}","page":"API reference","title":"TheoryOfGames.specific_in_core","text":"specific_in_core(mode, player_set, utilities, optimizer; verbose)\n\nFunction to calculte a profit distribution that belongs to the core  and maximizes a specific distribution objective specified by distobjective  for a game described by the utility function and the grand coalition of playerset. This function implements an iterative approach by using a column generating approach to iteratively add constraints to the master problem. To do so, the callback function stored in the mode category is exploited\n\nInputs\n\nmode : IterMode     Calculation mode that contains the reference to the callback function     that given a profit distribution scheme, returns a tuple of     the set of the coalition with the worst profit and its total benefit to be shared     callbackworstcoalition accepts one argument (current profit sharing) distobjective : Function     Function to build the objective function of the profit distribution     It shall a function with two arguments, which are the JuMP model and the player set,     and it shall build the objective functions using the JuMP @NLobjective or @objective     commands optimizer : Any     Optimizer function for the JuMP model used for computation purposes starttime : (optional, default nothing)     Specify the initial time of the method; if nothing the value is initialized by time() rtol : Number (optional, default 1e-2)     Relative tolerance of the convergence process atol : Number (optional, default 1e-2)     Absolute tolerance of the convergence process lowerbound : Number (optional, default nothing)     Lower bound of the variables of the problem (benefit distribution and margin of the worst coalition) upperbound : Number (optional, default nothing)     Upper bound of the variables of the problem (benefit distribution and margin of the worst coalition)     When nothing, the value is automatically set to the benefit of the grand coalition verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status rawoutputs : Bool (optional, default false)     When true, it returns all raw outputs usestartvalue : Bool (optional, default false)     When true, in the iterative process the previous iteration value is used as initialization     for the followin iteration maxiter : Bool (optional, default 100)     Maximum number of iterations of the process preloadcoalitions : Vector (optional, default empty)     List of coalitions whose benefit shall be automatically     included before the iterative procedure starts bestobjectivestopoption : String (optional, default nothing)     Name of the option to stop the lower problem as it reaches a preset value.     When this option is nothing, this feature is not used.     When this option is non-nothing, in every iteration, a minimum convergence criterion is added     so to stop the lower problem as soon as a minimum fesible objective function is reached.     This minimum objective value after which the solver shall return the solution     is provided as the option bestobjectivestopvalue     If gurobi is used, this option is BestObjStop bestobjectivestopvalue : Number (optional, default -1e-2)     Minimum objective function used for the solver to converge     When the procedure starts looping lowerrelaxationstopoption : String (optional, default nothing)     Name of the option used to setup the stop criterion of the optimization as soon as     the lowest bound reaches the tolerance specified by tolerancelowerrelaxationstop option tolerancelowerrelaxationstop : double (optional, default 0.0)     When lowerrelaxationstopoption is enabled, this option specifies the tolerance used     to stop the loop\n\nOutputs\n\nprofitdistribution     Benefit distribution by player minsurplus     Benefit of the coalition with the minimum surplus history\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.specific_least_core-Tuple{EnumMode, Function, Any}","page":"API reference","title":"TheoryOfGames.specific_least_core","text":"specific_least_core(mode, dist_objective, optimizer; verbose, raw_outputs)\n\nFunction to calculte a stable profit distribution that belongs to the least core and minimizes a specific objective for the profit allocation among the plauers, for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique distobjective : Function     Function to build the objective function of the profit distribution, after the least core     is obtained     It shall be a function with two arguments: the JuMP model of the problem and the player set,     and the function shall build the desired objective functions using the      JuMP @NLobjective or @objective commands optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status rawoutputs : Bool (optional, default false)     When true, it returns all raw outputs\n\nOutputs\n\nspecificleastcore_dist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.specific_least_core-Tuple{IterMode, Function, Any}","page":"API reference","title":"TheoryOfGames.specific_least_core","text":"specificleastcore(mode, distobjective, playerset, utilities, optimizer; verbose)\n\nFunction to calculte the least core profit distribution for a game described by the utility function and the grand coalition of player_set. This function implements an iterative approach by using a column generating approach to iteratively add constraints to the master problem. To do so, the callback function stored in the mode category is exploited\n\nInputs\n\nmode : IterMode     Calculation mode that contains the reference to the callback function     that given a profit distribution scheme, returns a tuple of     the set of the coalition with the worst profit and its total benefit to be shared     callbackworstcoalition accepts one argument (current profit sharing) distobjective : Function     Function to build the objective function of the profit distribution, after the least core     is obtained     It shall be a function with two arguments: the JuMP model of the problem and the player set,     and the function shall build the desired objective functions using the      JuMP @NLobjective or @objective commands optimizer : Any     Optimizer function for the JuMP model used for computation purposes starttime : (optional, default nothing)     Specify the initial time of the method; if nothing the value is initialized by time() rtol : Number (optional, default 1e-2)     Relative tolerance of the convergence process atol : Number (optional, default 1e-2)     Absolute tolerance of the convergence process lowerbound : Number (optional, default nothing)     Lower bound of the variables of the problem (benefit distribution and margin of the worst coalition) upperbound : Number (optional, default nothing)     Upper bound of the variables of the problem (benefit distribution and margin of the worst coalition)     When nothing, the value is automatically set to the benefit of the grand coalition verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status rawoutputs : Bool (optional, default false)     When true, it returns all raw outputs usestartvalue : Bool (optional, default false)     When true, in the iterative process the previous iteration value is used as initialization     for the followin iteration maxiter : Bool (optional, default 100)     Maximum number of iterations of the process bestobjectivestopoption : String (optional, default nothing)     Name of the option to stop the lower problem as it reaches a preset value.     When this option is nothing, this feature is not used.     When this option is non-nothing, in every iteration, a minimum convergence criterion is added     so to stop the lower problem as soon as a minimum fesible objective function is reached.     This minimum objective value is obtained with respect to the solution of the master problem     multiplied by the factor \"bestobjectivestoptolerance\"     If gurobi is used, this option is BestObjStop bestobjectivestoptolerance : Number (optional, default 0.05)     Tolerance used in the \"bestobjectivestopoption\" approach lowerrelaxationstopoption : String (optional, default nothing)     Name of the option used to setup the stop criterion of the optimization as soon as     the lowest bound reaches the tolerance specified by tolerancelowerrelaxationstop option tolerancelowerrelaxationstop : double (optional, default 0.0)     When lowerrelaxationstopoption is enabled, this option specifies the tolerance used     to stop the loop\n\nOutputs\n\nprofitdistribution     Benefit distribution by player minsurplus     Benefit of the coalition with the minimum surplus history\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.utility_combs-Tuple{Any, Function}","page":"API reference","title":"TheoryOfGames.utility_combs","text":"utility_combs(player_set, utility)\n\nFunction to calculate the utility for every combination of players. This table may be used in Game Theory, such as in the calculation of the shapley value. The function iterates all combinations of players in the player_set and execute the utility function to identify the benefits to be shared.\n\nInputs\n\nplayer_set : Vector     Vector of the players utility : Function     Utility function that given any coalition returns the benefit of the coalition     It shall be a function utility(::Vector)::T<:Number verbose : Bool     When true, it shows a progress bar to describe the current execution status parallel : Bool     When true, paralleling is used to compute operations\n\nOutputs\n\nutilities : Dict     Dictionary that specifies the utility of each combination of coalition in player_set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.utility_io_types-Tuple{Any, Function}","page":"API reference","title":"TheoryOfGames.utility_io_types","text":"Function to get the types of the utility arguments and outputs\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.var_in_core-Tuple{EnumMode, Any}","page":"API reference","title":"TheoryOfGames.var_in_core","text":"var_in_core(mode, optimizer; verbose)\n\nFunction to calculte a stable profit distribution that belongs to the core and minimizes the variance of the profit allocation among the plauers for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nvar_core : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.var_in_core-Tuple{IterMode, Any}","page":"API reference","title":"TheoryOfGames.var_in_core","text":"var_in_core(mode, optimizer; verbose)\n\nFunction to calculte a stable profit distribution that belongs to the core and minimizes the variance of the profit allocation among the plauers for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : IterMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes numerical_multiplier : Float (default 1e-3)     Multiplier to adjust numerical issues verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nvarincore : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.var_least_core-Tuple{EnumMode, Any}","page":"API reference","title":"TheoryOfGames.var_least_core","text":"var_least_core(mode, optimizer; verbose)\n\nFunction to calculte a stable profit distribution that belongs to the least core and minimizes the variance of the profit allocation among the players for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nspecificleastcore_dist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.var_least_core-Tuple{IterMode, Any}","page":"API reference","title":"TheoryOfGames.var_least_core","text":"var_least_core(mode, optimizer; verbose)\n\nFunction to calculte a stable profit distribution that belongs to the least core and minimizes the variance of the profit allocation among the players for a game described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes numerical_multiplier : Float (default 1e-3)     Multiplier to adjust numerical issues verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nspecificleastcore_dist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.verify_in_core-Tuple{Any, EnumMode, Any}","page":"API reference","title":"TheoryOfGames.verify_in_core","text":"verify_in_core(profit_dist, mode, optimizer; verbose, utilities)\n\nFunction to calculte whether a given profit distribution belongs to the core. The game shall be described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nincoredist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.verify_in_core-Tuple{Any, IterMode, Any}","page":"API reference","title":"TheoryOfGames.verify_in_core","text":"verify_in_core(profit_dist, mode, optimizer; verbose, utilities)\n\nFunction to calculte whether a given profit distribution belongs to the core. The game shall be described by the utility function and the grand coalition of player_set.\n\nInputs\n\nmode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status\n\nOutputs\n\nincoredist : Dict     Dictionary of the fair distributions of the profits among the players\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.EnumMode","page":"API reference","title":"TheoryOfGames.EnumMode","text":"EnumMode is a structure defining the enumerative representation of the\nutilities of a Game\n\n\n\n\n\n","category":"type"},{"location":"API reference/#TheoryOfGames.IterMode","page":"API reference","title":"TheoryOfGames.IterMode","text":"IterMode is a structure defining the modality for interative identification\nof the benefit distribution mechanism\n\nFields\n\nplayerset     Vector of players callbackbenefitbycoalition : Function     Callback function that is used to determine what is the benefit of a coalition     and the total benefit of the coalition callbackworstcoalition : Function     Callback function that is used to determine what is the coalition with the worst benefit     and the total benefit of the coalition.     Arguments shall be:     - (mandatory) a Dict-like container to describe the current reward distribution by user     - kwargs (optional):         - modifysolveroptions: vector of pairs to iteratively change the optimization callback             to speed up computation time. The implemented callbacks are:             1. bestobjstop: when the bestobjstop callback is used in iterative methods,                 the corresponding option is updated here depending on the value             2. lowerrelaxationstopoption: option to stop the execution as a lower bound is reached     The function shall return a Vector of NamedTuple, where for every entry o shall contain:     - leastprofitablecoalition: members of the worst coalition, for result o     - coalitionbenefit: benefit of the coalition, for result o     - min_surplus: minimum surplus of the coalition, for result o\n\n\n\n\n\n","category":"type"},{"location":"#TheoryOfGames.jl-Documentation","page":"Home","title":"TheoryOfGames.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TheoryOfGames is a package for game-theory applications.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently supported functions include the following reward distribution techniques:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shapely Value\nCore\nLeastCore\nNucleolus\nVarLeastCore\nVarCore","category":"page"}]
}
