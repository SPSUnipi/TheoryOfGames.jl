<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · TheoryOfGames.jl</title><meta name="title" content="API reference · TheoryOfGames.jl"/><meta property="og:title" content="API reference · TheoryOfGames.jl"/><meta property="twitter:title" content="API reference · TheoryOfGames.jl"/><meta name="description" content="Documentation for TheoryOfGames.jl."/><meta property="og:description" content="Documentation for TheoryOfGames.jl."/><meta property="twitter:description" content="Documentation for TheoryOfGames.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TheoryOfGames.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/example_three_users_atleasttwo/">Example 1: Key player but not alone</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SPSUnipi/TheoryOfGames.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/main/docs/src/API reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FileIO.load-Tuple{AbstractString, AbstractCalcMode}"><a class="docstring-binding" href="#FileIO.load-Tuple{AbstractString, AbstractCalcMode}"><code>FileIO.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load(output_file::AbstractString)</code></pre><p>Function to load the results and the model to the hard drive</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/io.jl#L24-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FileIO.save-Tuple{AbstractString, AbstractCalcMode}"><a class="docstring-binding" href="#FileIO.save-Tuple{AbstractString, AbstractCalcMode}"><code>FileIO.save</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save(output_file::AbstractString, game_mode&lt;:AbstractCalcMode)</code></pre><p>Function to save the Mode element of TheoryOfGames.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/io.jl#L11-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames._create_history_row-NTuple{8, Any}"><a class="docstring-binding" href="#TheoryOfGames._create_history_row-NTuple{8, Any}"><code>TheoryOfGames._create_history_row</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Auxiliary function to create history rows for iterative solving methods</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/common.jl#L86-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.compute_relative_tol"><a class="docstring-binding" href="#TheoryOfGames.compute_relative_tol"><code>TheoryOfGames.compute_relative_tol</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Auxiliary function to compute the relative tolerance between two quantities x and y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/common.jl#L78-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.empty_set-Tuple{Any}"><a class="docstring-binding" href="#TheoryOfGames.empty_set-Tuple{Any}"><code>TheoryOfGames.empty_set</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the empty set of the coalition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/common.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.in_core-Tuple{EnumMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.in_core-Tuple{EnumMode, Any}"><code>TheoryOfGames.in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">in_core(mode, optimizer; verbose, raw_outputs)</code></pre><p>Function to calculte a stable profit distribution that belongs to the core for profit distribution for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>in<em>core</em>dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L356-L376">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.in_core-Tuple{IterMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.in_core-Tuple{IterMode, Any}"><code>TheoryOfGames.in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">in_core(mode, optimizer; verbose, ...)</code></pre><p>Function to calculte a stable profit distribution that belongs to the core for profit distribution for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : IterMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>in<em>core</em>dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L1021-L1041">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.least_core-Tuple{EnumMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.least_core-Tuple{EnumMode, Any}"><code>TheoryOfGames.least_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">least_core(mode, utilities, optimizer; verbose, raw_outputs)</code></pre><p>Function to calculte the least core profit distribution for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique player<em>set : Vector     Vector of the players of the coalition optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status raw</em>outputs : Bool (optional, default false)     When true, it returns all raw outputs</p><p><strong>Outputs</strong></p><p>leastcore_dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L51-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.least_core-Tuple{IterMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.least_core-Tuple{IterMode, Any}"><code>TheoryOfGames.least_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>least<em>core(mode, player</em>set, utilities, optimizer; verbose)</p><p>Function to calculte the least core profit distribution for a game described by the utility function and the grand coalition of player_set. This function implements an iterative approach by using a column generating approach to iteratively add constraints to the master problem. To do so, the callback function stored in the mode category is exploited</p><p><strong>Inputs</strong></p><p>mode : IterMode     Calculation mode that contains the reference to the callback function     that given a profit distribution scheme, returns a tuple of     the set of the coalition with the worst profit and its total benefit to be shared     callback<em>worst</em>coalition accepts one argument (current profit sharing) optimizer : Any     Optimizer function for the JuMP model used for computation purposes start<em>time : (optional, default nothing)     Specify the initial time of the method; if nothing the value is initialized by time() rtol : Number (optional, default 1e-2)     Relative tolerance of the convergence process atol : Number (optional, default 1e-2)     Absolute tolerance of the convergence process lower</em>bound : Number (optional, default nothing)     Lower bound of the variables of the problem (benefit distribution and margin of the worst coalition) upper<em>bound : Number (optional, default nothing)     Upper bound of the variables of the problem (benefit distribution and margin of the worst coalition)     When nothing, the value is automatically set to the benefit of the grand coalition verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status raw</em>outputs : Bool (optional, default false)     When true, it returns all raw outputs use<em>start</em>value : Bool (optional, default false)     When true, in the iterative process the previous iteration value is used as initialization     for the followin iteration max<em>iter : Bool (optional, default 100)     Maximum number of iterations of the process preload</em>coalitions : Vector (optional, default empty)     List of coalitions whose benefit shall be automatically     included before the iterative procedure starts best<em>objective</em>stop<em>option : String (optional, default nothing)     Name of the option to stop the lower problem as it reaches a preset value.     When this option is nothing, this feature is not used.     When this option is non-nothing, in every iteration, a minimum convergence criterion is added     so to stop the lower problem as soon as a minimum fesible objective function is reached.     This minimum objective value is obtained with respect to the solution of the master problem     multiplied by the factor &quot;best</em>objective<em>stop</em>tolerance&quot;     If gurobi is used, this option is BestObjStop best<em>objective</em>stop<em>tolerance : Number (optional, default 0.05)     Tolerance used in the &quot;best</em>objective<em>stop</em>option&quot; approach lower<em>relaxation</em>stop<em>option : String (optional, default nothing)     Name of the option used to setup the stop criterion of the optimization as soon as     the lowest bound reaches the tolerance specified by tolerance</em>lower<em>relaxation</em>stop option tolerance<em>lower</em>relaxation<em>stop : double (optional, default 0.0)     When lower</em>relaxation<em>stop</em>option is enabled, this option specifies the tolerance used     to stop the loop</p><p><strong>Outputs</strong></p><p>profit<em>distribution     Benefit distribution by player min</em>surplus     Benefit of the coalition with the minimum surplus history</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L1-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.nucleolus-Tuple{EnumMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.nucleolus-Tuple{EnumMode, Any}"><code>TheoryOfGames.nucleolus</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nucleolus(mode, utilities; verbose, tol, raw_outputs)</code></pre><p>Function to calculte the nucleolus profit distribution for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status tol (optional, default 1e-5)     Accepted tolerance for identifying the active constraints in the optimization     procedure raw_outputs : Bool (optional, default false)     When true, it returns all raw outputs</p><p><strong>Outputs</strong></p><p>nucleolus_dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L126-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.number_coalitions-Tuple{Any}"><a class="docstring-binding" href="#TheoryOfGames.number_coalitions-Tuple{Any}"><code>TheoryOfGames.number_coalitions</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Get the total number of coalitions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/common.jl#L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.ref_in_core-Tuple{EnumMode, Any, Any}"><a class="docstring-binding" href="#TheoryOfGames.ref_in_core-Tuple{EnumMode, Any, Any}"><code>TheoryOfGames.ref_in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ref_in_core(mode, ref_dist, optimizer; verbose)</code></pre><p>Function to calculte a stable profit distribution that belongs to the core and minimizes the variance of the profit allocation among the players with respect to a pre-defined reward distribution function for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique ref_dist : AbstrctDict     Reference distribution by player optimizer : Any     Optimizer function for the JuMP model used for computation purposes norm : Any     Normalization denominator for every player     Default value nothing, hence for every player the Normalization     factor is 1.0 verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>specific<em>ref</em>in<em>core</em>dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L429-L457">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.ref_in_core-Tuple{IterMode, Any, Any}"><a class="docstring-binding" href="#TheoryOfGames.ref_in_core-Tuple{IterMode, Any, Any}"><code>TheoryOfGames.ref_in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ref_in_core(mode, ref_dist, optimizer; verbose)</code></pre><p>Function to calculte a stable profit distribution that belongs to the core and minimizes the variance of the profit allocation among the players with respect to a pre-defined reward distribution function for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : IterMode     Calculation mode: enumerative technique ref<em>dist : AbstrctDict     Reference distribution by player optimizer : Any     Optimizer function for the JuMP model used for computation purposes norm : Any     Normalization denominator for every player     Default value nothing, hence for every player the Normalization     factor is 1.0 numerical</em>multiplier : Float (default 1e-3)     Multiplier to adjust numerical issues verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>specific<em>ref</em>in<em>core</em>dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L1096-L1126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.ref_least_core-Tuple{EnumMode, Any, Any}"><a class="docstring-binding" href="#TheoryOfGames.ref_least_core-Tuple{EnumMode, Any, Any}"><code>TheoryOfGames.ref_least_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ref_least_core(mode, ref_dist, optimizer; norm, verbose)</code></pre><p>Function to calculte a stable profit distribution that belongs to the least core and minimizes the variance of the profit allocation among the players with respect to a pre-defined reward distribution function for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : AbstractCalcMode     Calculation mode: enumerative technique ref_dist : AbstrctDict     Reference distribution by player optimizer : Any     Optimizer function for the JuMP model used for computation purposes norm (optional, default nothing)     Normalization denominator for every player     Default value nothing, hence for every player the Normalization     factor is 1.0 verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>specific<em>least</em>core_dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L665-L693">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.ref_least_core-Tuple{IterMode, Any, Any}"><a class="docstring-binding" href="#TheoryOfGames.ref_least_core-Tuple{IterMode, Any, Any}"><code>TheoryOfGames.ref_least_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ref_least_core(mode, ref_dist, optimizer; norm, verbose)</code></pre><p>Function to calculte a stable profit distribution that belongs to the least core and minimizes the variance of the profit allocation among the players with respect to a pre-defined reward distribution function for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : AbstractCalcMode     Calculation mode: enumerative technique ref_dist : AbstrctDict     Reference distribution by player optimizer : Any     Optimizer function for the JuMP model used for computation purposes norm (optional, default nothing)     Normalization denominator for every player     Default value nothing, hence for every player the Normalization     factor is 1.0 verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>specific<em>least</em>core_dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L651-L679">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.shapley_value-Tuple{EnumMode}"><a class="docstring-binding" href="#TheoryOfGames.shapley_value-Tuple{EnumMode}"><code>TheoryOfGames.shapley_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">shapley_value(mode; verbose)</code></pre><p>Function to calculte the shapley value for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>shapley_value : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.specific_in_core-Tuple{EnumMode, Function, Any}"><a class="docstring-binding" href="#TheoryOfGames.specific_in_core-Tuple{EnumMode, Function, Any}"><code>TheoryOfGames.specific_in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">specific_in_core(mode, dist_objective, optimizer; verbose, raw_outputs)</code></pre><p>Function to calculte a stable profit distribution that belongs to the core and maximizes a specific distribution objective specified by dist<em>objective for a game described by the utility function and the grand coalition of player</em>set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique dist<em>objective : Function     Function to build the objective function of the profit distribution     It shall a function with two arguments, which are the JuMP model and the player set,     and it shall build the objective functions using the JuMP @NLobjective or @objective     commands optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status raw</em>outputs : Bool (optional, default false)     When true, it returns all raw outputs</p><p><strong>Outputs</strong></p><p>specific<em>in</em>core_dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L279-L306">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.specific_in_core-Tuple{IterMode, Function, Any}"><a class="docstring-binding" href="#TheoryOfGames.specific_in_core-Tuple{IterMode, Function, Any}"><code>TheoryOfGames.specific_in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">specific_in_core(mode, player_set, utilities, optimizer; verbose)</code></pre><p>Function to calculte a profit distribution that belongs to the core  and maximizes a specific distribution objective specified by dist<em>objective  for a game described by the utility function and the grand coalition of player</em>set. This function implements an iterative approach by using a column generating approach to iteratively add constraints to the master problem. To do so, the callback function stored in the mode category is exploited</p><p><strong>Inputs</strong></p><p>mode : IterMode     Calculation mode that contains the reference to the callback function     that given a profit distribution scheme, returns a tuple of     the set of the coalition with the worst profit and its total benefit to be shared     callback<em>worst</em>coalition accepts one argument (current profit sharing) dist<em>objective : Function     Function to build the objective function of the profit distribution     It shall a function with two arguments, which are the JuMP model and the player set,     and it shall build the objective functions using the JuMP @NLobjective or @objective     commands optimizer : Any     Optimizer function for the JuMP model used for computation purposes start</em>time : (optional, default nothing)     Specify the initial time of the method; if nothing the value is initialized by time() rtol : Number (optional, default 1e-2)     Relative tolerance of the convergence process atol : Number (optional, default 1e-2)     Absolute tolerance of the convergence process lower<em>bound : Number (optional, default nothing)     Lower bound of the variables of the problem (benefit distribution and margin of the worst coalition) upper</em>bound : Number (optional, default nothing)     Upper bound of the variables of the problem (benefit distribution and margin of the worst coalition)     When nothing, the value is automatically set to the benefit of the grand coalition verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status raw<em>outputs : Bool (optional, default false)     When true, it returns all raw outputs use</em>start<em>value : Bool (optional, default false)     When true, in the iterative process the previous iteration value is used as initialization     for the followin iteration max</em>iter : Bool (optional, default 100)     Maximum number of iterations of the process preload<em>coalitions : Vector (optional, default empty)     List of coalitions whose benefit shall be automatically     included before the iterative procedure starts best</em>objective<em>stop</em>option : String (optional, default nothing)     Name of the option to stop the lower problem as it reaches a preset value.     When this option is nothing, this feature is not used.     When this option is non-nothing, in every iteration, a minimum convergence criterion is added     so to stop the lower problem as soon as a minimum fesible objective function is reached.     This minimum objective value after which the solver shall return the solution     is provided as the option best<em>objective</em>stop<em>value     If gurobi is used, this option is BestObjStop best</em>objective<em>stop</em>value : Number (optional, default -1e-2)     Minimum objective function used for the solver to converge     When the procedure starts looping lower<em>relaxation</em>stop<em>option : String (optional, default nothing)     Name of the option used to setup the stop criterion of the optimization as soon as     the lowest bound reaches the tolerance specified by tolerance</em>lower<em>relaxation</em>stop option tolerance<em>lower</em>relaxation<em>stop : double (optional, default 0.0)     When lower</em>relaxation<em>stop</em>option is enabled, this option specifies the tolerance used     to stop the loop</p><p><strong>Outputs</strong></p><p>profit<em>distribution     Benefit distribution by player min</em>surplus     Benefit of the coalition with the minimum surplus history</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L712-L784">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.specific_least_core-Tuple{EnumMode, Function, Any}"><a class="docstring-binding" href="#TheoryOfGames.specific_least_core-Tuple{EnumMode, Function, Any}"><code>TheoryOfGames.specific_least_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">specific_least_core(mode, dist_objective, optimizer; verbose, raw_outputs)</code></pre><p>Function to calculte a stable profit distribution that belongs to the least core and minimizes a specific objective for the profit allocation among the plauers, for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique dist<em>objective : Function     Function to build the objective function of the profit distribution, after the least core     is obtained     It shall be a function with two arguments: the JuMP model of the problem and the player set,     and the function shall build the desired objective functions using the      JuMP @NLobjective or @objective commands optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status raw</em>outputs : Bool (optional, default false)     When true, it returns all raw outputs</p><p><strong>Outputs</strong></p><p>specific<em>least</em>core_dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L535-L563">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.specific_least_core-Tuple{IterMode, Function, Any}"><a class="docstring-binding" href="#TheoryOfGames.specific_least_core-Tuple{IterMode, Function, Any}"><code>TheoryOfGames.specific_least_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>specific<em>least</em>core(mode, dist<em>objective, player</em>set, utilities, optimizer; verbose)</p><p>Function to calculte the least core profit distribution for a game described by the utility function and the grand coalition of player_set. This function implements an iterative approach by using a column generating approach to iteratively add constraints to the master problem. To do so, the callback function stored in the mode category is exploited</p><p><strong>Inputs</strong></p><p>mode : IterMode     Calculation mode that contains the reference to the callback function     that given a profit distribution scheme, returns a tuple of     the set of the coalition with the worst profit and its total benefit to be shared     callback<em>worst</em>coalition accepts one argument (current profit sharing) dist<em>objective : Function     Function to build the objective function of the profit distribution, after the least core     is obtained     It shall be a function with two arguments: the JuMP model of the problem and the player set,     and the function shall build the desired objective functions using the      JuMP @NLobjective or @objective commands optimizer : Any     Optimizer function for the JuMP model used for computation purposes start</em>time : (optional, default nothing)     Specify the initial time of the method; if nothing the value is initialized by time() rtol : Number (optional, default 1e-2)     Relative tolerance of the convergence process atol : Number (optional, default 1e-2)     Absolute tolerance of the convergence process lower<em>bound : Number (optional, default nothing)     Lower bound of the variables of the problem (benefit distribution and margin of the worst coalition) upper</em>bound : Number (optional, default nothing)     Upper bound of the variables of the problem (benefit distribution and margin of the worst coalition)     When nothing, the value is automatically set to the benefit of the grand coalition verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status raw<em>outputs : Bool (optional, default false)     When true, it returns all raw outputs use</em>start<em>value : Bool (optional, default false)     When true, in the iterative process the previous iteration value is used as initialization     for the followin iteration max</em>iter : Bool (optional, default 100)     Maximum number of iterations of the process best<em>objective</em>stop<em>option : String (optional, default nothing)     Name of the option to stop the lower problem as it reaches a preset value.     When this option is nothing, this feature is not used.     When this option is non-nothing, in every iteration, a minimum convergence criterion is added     so to stop the lower problem as soon as a minimum fesible objective function is reached.     This minimum objective value is obtained with respect to the solution of the master problem     multiplied by the factor &quot;best</em>objective<em>stop</em>tolerance&quot;     If gurobi is used, this option is BestObjStop best<em>objective</em>stop<em>tolerance : Number (optional, default 0.05)     Tolerance used in the &quot;best</em>objective<em>stop</em>option&quot; approach lower<em>relaxation</em>stop<em>option : String (optional, default nothing)     Name of the option used to setup the stop criterion of the optimization as soon as     the lowest bound reaches the tolerance specified by tolerance</em>lower<em>relaxation</em>stop option tolerance<em>lower</em>relaxation<em>stop : double (optional, default 0.0)     When lower</em>relaxation<em>stop</em>option is enabled, this option specifies the tolerance used     to stop the loop</p><p><strong>Outputs</strong></p><p>profit<em>distribution     Benefit distribution by player min</em>surplus     Benefit of the coalition with the minimum surplus history</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L309-L377">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.utility_combs-Tuple{Any, Function}"><a class="docstring-binding" href="#TheoryOfGames.utility_combs-Tuple{Any, Function}"><code>TheoryOfGames.utility_combs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">utility_combs(player_set, utility)</code></pre><p>Function to calculate the utility for every combination of players. This table may be used in Game Theory, such as in the calculation of the shapley value. The function iterates all combinations of players in the player_set and execute the utility function to identify the benefits to be shared.</p><p><strong>Inputs</strong></p><p>player_set : Vector     Vector of the players utility : Function     Utility function that given any coalition returns the benefit of the coalition     It shall be a function utility(::Vector)::T&lt;:Number verbose : Bool     When true, it shows a progress bar to describe the current execution status parallel : Bool     When true, paralleling is used to compute operations</p><p><strong>Outputs</strong></p><p>utilities : Dict     Dictionary that specifies the utility of each combination of coalition in player_set</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/common.jl#L17-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.utility_io_types-Tuple{Any, Function}"><a class="docstring-binding" href="#TheoryOfGames.utility_io_types-Tuple{Any, Function}"><code>TheoryOfGames.utility_io_types</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Function to get the types of the utility arguments and outputs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/common.jl#L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.var_in_core-Tuple{EnumMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.var_in_core-Tuple{EnumMode, Any}"><code>TheoryOfGames.var_in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var_in_core(mode, optimizer; verbose)</code></pre><p>Function to calculte a stable profit distribution that belongs to the core and minimizes the variance of the profit allocation among the plauers for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>var_core : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L391-L411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.var_in_core-Tuple{IterMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.var_in_core-Tuple{IterMode, Any}"><code>TheoryOfGames.var_in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var_in_core(mode, optimizer; verbose)</code></pre><p>Function to calculte a stable profit distribution that belongs to the core and minimizes the variance of the profit allocation among the plauers for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : IterMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes numerical_multiplier : Float (default 1e-3)     Multiplier to adjust numerical issues verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>var<em>in</em>core : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L1056-L1078">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.var_least_core-Tuple{EnumMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.var_least_core-Tuple{EnumMode, Any}"><code>TheoryOfGames.var_least_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var_least_core(mode, optimizer; verbose)</code></pre><p>Function to calculte a stable profit distribution that belongs to the least core and minimizes the variance of the profit allocation among the players for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>specific<em>least</em>core_dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L622-L643">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.var_least_core-Tuple{IterMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.var_least_core-Tuple{IterMode, Any}"><code>TheoryOfGames.var_least_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var_least_core(mode, optimizer; verbose)</code></pre><p>Function to calculte a stable profit distribution that belongs to the least core and minimizes the variance of the profit allocation among the players for a game described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes numerical_multiplier : Float (default 1e-3)     Multiplier to adjust numerical issues verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>specific<em>least</em>core_dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L605-L628">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.verify_in_core-Tuple{Any, EnumMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.verify_in_core-Tuple{Any, EnumMode, Any}"><code>TheoryOfGames.verify_in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">verify_in_core(profit_dist, mode, optimizer; verbose, utilities)</code></pre><p>Function to calculte whether a given profit distribution belongs to the core. The game shall be described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>in<em>core</em>dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_enumerative.jl#L489-L508">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.verify_in_core-Tuple{Any, IterMode, Any}"><a class="docstring-binding" href="#TheoryOfGames.verify_in_core-Tuple{Any, IterMode, Any}"><code>TheoryOfGames.verify_in_core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">verify_in_core(profit_dist, mode, optimizer; verbose, utilities)</code></pre><p>Function to calculte whether a given profit distribution belongs to the core. The game shall be described by the utility function and the grand coalition of player_set.</p><p><strong>Inputs</strong></p><p>mode : EnumMode     Calculation mode: enumerative technique optimizer : Any     Optimizer function for the JuMP model used for computation purposes verbose : Bool (optional, default true)     When true, it shows a progress bar to describe the current execution status</p><p><strong>Outputs</strong></p><p>in<em>core</em>dist : Dict     Dictionary of the fair distributions of the profits among the players</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/cooperative_iterative.jl#L1159-L1178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.EnumMode"><a class="docstring-binding" href="#TheoryOfGames.EnumMode"><code>TheoryOfGames.EnumMode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EnumMode is a structure defining the enumerative representation of the
utilities of a Game</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/mode_definitions.jl#L3-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TheoryOfGames.IterMode"><a class="docstring-binding" href="#TheoryOfGames.IterMode"><code>TheoryOfGames.IterMode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterMode is a structure defining the modality for interative identification
of the benefit distribution mechanism</code></pre><p><strong>Fields</strong></p><p>player<em>set     Vector of players callback</em>benefit<em>by</em>coalition : Function     Callback function that is used to determine what is the benefit of a coalition     and the total benefit of the coalition callback<em>worst</em>coalition : Function     Callback function that is used to determine what is the coalition with the worst benefit     and the total benefit of the coalition.     Arguments shall be:     - (mandatory) a Dict-like container to describe the current reward distribution by user     - kwargs (optional):         - modify<em>solver</em>options: vector of pairs to iteratively change the optimization callback             to speed up computation time. The implemented callbacks are:             1. best<em>obj</em>stop: when the best<em>obj</em>stop callback is used in iterative methods,                 the corresponding option is updated here depending on the value             2. lower<em>relaxation</em>stop<em>option: option to stop the execution as a lower bound is reached     The function shall return a Vector of NamedTuple, where for every entry o shall contain:     - least</em>profitable<em>coalition: members of the worst coalition, for result o     - coalition</em>benefit: benefit of the coalition, for result o     - min_surplus: minimum surplus of the coalition, for result o</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SPSUnipi/TheoryOfGames.jl/blob/2637786ae0a2c66d09e94b756f1b605c4ccefc21/src/mode_definitions.jl#L33-L59">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/example_three_users_atleasttwo/">« Example 1: Key player but not alone</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 2 December 2025 22:03">Tuesday 2 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
